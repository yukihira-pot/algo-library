{
	// Place your CppScript ワークスペース snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }

    "vi": {
        "prefix": "veci",
        "body": [
            "vector<int> ",
        ],
        "description": ""
    },

    "vl": {
        "prefix": "vecl",
        "body": [
            "vector<ll> ",
        ],
        "description": ""
    },

    "vvi": {
        "prefix": "vveci",
        "body": [
            "vector<vector<int>> ",
        ],
        "description": ""
    },

    "vvl": {
        "prefix": "vvecl",
        "body": [
            "vector<vector<ll>> ",
        ],
        "description": ""
    },

    "vb": {
        "prefix": "vecb",
        "body": [
            "vector<bool> ",
        ],
        "description": ""
    },

    "vvb": {
        "prefix": "vvecb",
        "body": [
            "vector<vector<bool>> ",
        ],
        "description": ""
    },

    "vs": {
        "prefix": "vecs",
        "body": [
            "vector<string> ",
        ],
        "description": ""
    },

    "vvc": {
        "prefix": "vvecc",
        "body": [
            "vector<vector<char>> ",
        ],
        "description": ""
    },

    "vm": {
        "prefix": "vecm",
        "body": [
            "vector<mint> ",
        ],
        "description": ""
    },

    "vvm": {
        "prefix": "vvecm",
        "body": [
            "vector<vector<mint>> ",
        ],
        "description": ""
    },



    "cpmain": {
        "prefix": "cpmain",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "#define _overload(_1, _2, _3, name, ...) name",
            "#define rep2(i, n) rep3(i, 0, n)",
            "#define rep3(i, a, b) for (ll i = (a); i < (ll)(b); i++)",
            "#define rep(...) _overload(__VA_ARGS__, rep3, rep2)(__VA_ARGS__)",
            "#define rrep(i, a, b) for (ll i = a; i >= b; i--)",
            "#define fore(e, a) for (auto &&e : a)",
            "#define all(x) (x).begin(), (x).end()",
            "",
            "using ll = long long;",
            "using ull = unsigned long long;",
            "",
            "template <typename T>",
            "istream &operator>>(istream &is, vector<T> &v) {",
            "    for (T &e : v) is >> e;",
            "    return is;",
            "}",
            "template <typename T>",
            "ostream &operator<<(ostream &os, const vector<T> &v) {",
            "    int sz = (int)v.size();",
            "    rep(i, sz) { os << v[i] << (i + 1 == sz ? \"\" : \" \"); }",
            "    return os;",
            "}",
            "",
            "template <typename T, typename U>",
            "inline bool chmin(T &a, U b) {",
            "    if (a > b) { a = b; return true; }",
            "    return false;",
            "}",
            "template <typename T, typename U>",
            "inline bool chmax(T &a, U b) {",
            "    if (a < b) { a = b; return true; }",
            "    return false;",
            "}",
            "",
            "#ifdef LOCAL",
            "#include \"assets/debug.h\"",
            "#else",
            "#define debug(...) (void(0))",
            "#endif",
            "",
            "const int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};",
            "const int dy[] = {1, -1, 0, 0, -1, 1, -1, 1};",
            "",
            "const int INFI = 1 << 30;   // 1.07e9",
            "const ll INFL = 1ll << 61;  // 2.30e18",
            "",
            "/* ------start coding here------ */",
            "",
            "",
            "",
            "",
            "void solve() {",
            "    $1",
            "}",
            "",
            "int main() {",
            "    cin.tie(nullptr);",
            "    ios::sync_with_stdio(false);",
            "",
            "    int testcases = 1;",
            "    // cin >> testcases;",
            "    while (testcases--) {",
            "        solve();",
            "    }",
            "}",
        ],
        "description": ""
    },

    "cfmain": {
        "prefix": "cfmain",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "#define _overload(_1, _2, _3, name, ...) name",
            "#define rep2(i, n) rep3(i, 0, n)",
            "#define rep3(i, a, b) for (ll i = (a); i < (ll)(b); i++)",
            "#define rep(...) _overload(__VA_ARGS__, rep3, rep2)(__VA_ARGS__)",
            "#define rrep(i, a, b) for (ll i = a; i >= b; i--)",
            "#define fore(e, a) for (auto &&e : a)",
            "#define all(x) (x).begin(), (x).end()",
            "",
            "using ll = long long;",
            "using ull = unsigned long long;",
            "",
            "template <typename T>",
            "istream &operator>>(istream &is, vector<T> &v) {",
            "    for (T &e : v) is >> e;",
            "    return is;",
            "}",
            "template <typename T>",
            "ostream &operator<<(ostream &os, const vector<T> &v) {",
            "    int sz = (int)v.size();",
            "    rep(i, sz) { os << v[i] << (i + 1 == sz ? \"\" : \" \"); }",
            "    return os;",
            "}",
            "",
            "template <typename T, typename U>",
            "inline bool chmin(T &a, U b) {",
            "    if (a > b) { a = b; return true; }",
            "    return false;",
            "}",
            "template <typename T, typename U>",
            "inline bool chmax(T &a, U b) {",
            "    if (a < b) { a = b; return true; }",
            "    return false;",
            "}",
            "",
            "#ifdef LOCAL",
            "#include \"assets/debug.h\"",
            "#else",
            "#define debug(...) (void(0))",
            "#endif",
            "",
            "const int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};",
            "const int dy[] = {1, -1, 0, 0, -1, 1, -1, 1};",
            "",
            "const int INFI = 1 << 30;   // 1.07e9",
            "const ll INFL = 1ll << 61;  // 2.30e18",
            "",
            "/* ------start coding here------ */",
            "",
            "",
            "",
            "",
            "void solve() {",
            "    $1",
            "}",
            "",
            "int main() {",
            "    cin.tie(nullptr);",
            "    ios::sync_with_stdio(false);",
            "",
            "    int testcases = 1;",
            "    cin >> testcases;",
            "    while (testcases--) {",
            "        solve();",
            "    }",
            "}",
        ],
        "description": ""
    },

    "LCA": {
        "prefix": "lowestcommonancestor",
        
        "body": [
            "struct LowestCommonAncestor {",
            "    // parent[k][v] := v の 2^k 個先の親",
            "    vector<vector<int>> parent;",
            "    // dist[i] := 根から i までの距離",
            "    vector<int> dist;",
            "",
            "    LowestCommonAncestor(const vector<vector<int>> &edges, int root=0) {",
            "        init(edges, root);",
            "    }",
            "",
            "    /*",
            "        前処理",
            "        O(N log N)",
            "    */",
            "    void init(const vector<vector<int>> &edges, int root=0) {",
            "        int vertex_size = (int)edges.size();",
            "        int log_vertex_size = 1;",
            "        while ((1 << log_vertex_size) < vertex_size) log_vertex_size++;",
            "        parent.assign(log_vertex_size, vector<int>(vertex_size, -1));",
            "        dist.assign(vertex_size, -1);",
            "        parent_init(edges, -1, root);",
            "        dist_from_root(edges, -1, root, 0);",
            "        // doubling",
            "        for (int k = 0; k + 1 < log_vertex_size; k++) {",
            "            for (int v = 0; v < vertex_size; v++) {",
            "                if (parent[k][v] < 0) parent[k + 1][v] = -1;",
            "                else parent[k + 1][v] = parent[k][parent[k][v]];",
            "            }",
            "        }",
            "    }",
            "",
            "    void parent_init(const vector<vector<int>> &edges, int pre, int cur) {",
            "        parent[0][cur] = pre;",
            "        for (auto& nxt : edges[cur]) {",
            "            if (nxt != pre) parent_init(edges, cur, nxt);",
            "        }",
            "    }",
            "",
            "    void dist_from_root(const vector<vector<int>> &edges, int pre, int cur, int dist_from_root_to_cur) {",
            "        dist[cur] = dist_from_root_to_cur;",
            "        for (auto& nxt : edges[cur]) {",
            "            if (nxt != pre) ",
            "                dist_from_root(edges, cur, nxt, dist_from_root_to_cur + 1);",
            "        }",
            "    }",
            "",
            "    /* ",
            "        頂点 u, v の LCA を求める",
            "        O(log N)",
            "     */",
            "    int query(int u, int v) {",
            "        // u : 深い方の頂点",
            "        if (dist[u] < dist[v]) swap(u, v);",
            "        int log_vertex_size = (int)parent.size();",
            "        // LCA までの距離を小さいほうに合わせる",
            "        for (int k = 0; k < log_vertex_size; k++) {",
            "            if (((dist[u] - dist[v]) >> k) & 1) u = parent[k][u];",
            "        }",
            "        // LCA を二分探索で求める",
            "        if (u == v) return u;",
            "        for (int k = log_vertex_size - 1; k >= 0; k--) {",
            "            if (parent[k][u] != parent[k][v]) {",
            "                u = parent[k][u];",
            "                v = parent[k][v];",
            "            }",
            "        }",
            "        return parent[0][u];",
            "    }",
            "",
            "    /*",
            "        頂点 u, v 間の距離を求める",
            "        O(log N)",
            "    */",
            "    int get_dist(int u, int v) {",
            "        return dist[u] + dist[v] - 2 * dist[query(u, v)];",
            "    }",
            "",
            "    /*",
            "        頂点 u, v を結ぶパス上に頂点 a が存在するかどうかを求める",
            "        O(log N)",
            "    */",
            "    int is_on_path(int u, int v, int a) {",
            "        return get_dist(u, a) + get_dist(a, v) == get_dist(u, v);",
            "    }",
            "};",
        ],
        "description": ""
    },

    "treediameter": {
        "prefix": "treediameter",
        
        "body": [
            "template <typename T>",
            "struct Edge {",
            "    int to;",
            "    T cost;",
            "};",
            "",
            "template <typename T>",
            "pair<T, int> dfs_for_tree_diameter(const vector<vector<Edge<T>>> &edges, int cur, int pre) {",
            "    pair<T, int> res = make_pair((T)0, cur);",
            "    for (auto &[nxt, cost] : edges[cur]) {",
            "        if (pre != nxt) {",
            "            pair<T, int> nxt_pair = dfs_for_tree_diameter<T>(edges, nxt, cur);",
            "            nxt_pair.first += cost;",
            "            res = max(res, nxt_pair);",
            "        }",
            "    }",
            "    return res;",
            "}",
            "template <typename T>",
            "tuple<int, int, T> tree_diameter(const vector<vector<Edge<T>>> &edges) {",
            "    pair<T, int> v1 = dfs_for_tree_diameter<T>(edges, 0, -1);",
            "    pair<T, int> v2 = dfs_for_tree_diameter<T>(edges, v1.second, -1);",
            "    return make_tuple(v1.second, v2.second, v2.first);",
            "}",
        ],
        "description": ""
    },

    "stronglyconnectedcomponents": {
        "prefix": "stronglyconnectedcomponents",
        
        "body": [
            "template <typename T>",
            "struct Edge {",
            "    int to;",
            "    T cost;",
            "};",
            "",
            "template <typename T>",
            "struct StronglyConnectedComponents {",
            "    int vertex_size;",
            "    vector<vector<Edge<T>>> edges, r_edges;",
            "    vector<int> order, component;",
            "    vector<bool> used, r_used;",
            "",
            "    StronglyConnectedComponents(vector<vector<Edge<T>>> &edges_) : ",
            "    vertex_size(edges_.size()), edges(edges_), ",
            "    r_edges(vertex_size), component(vertex_size), ",
            "    used(vertex_size), r_used(vertex_size) {",
            "            for (int cv = 0; cv < vertex_size; cv++) {",
            "                for (auto& [nv, cost] : edges[cv]) {",
            "                    r_edges[nv].push_back({cv, cost});",
            "                }",
            "            }",
            "            for (int cv = 0; cv < vertex_size; cv++) {",
            "                if (!used[cv]) dfs(cv);",
            "            }",
            "            reverse(order.begin(), order.end());",
            "            int component_idx = 0;",
            "            for (auto& cv : order) {",
            "                if (!r_used[cv]) {",
            "                    r_dfs(cv, component_idx);",
            "                    component_idx++;",
            "                }",
            "            }",
            "    }",
            "",
            "    void dfs(int cur_to) {",
            "        used[cur_to] = true;",
            "        for (auto& [nxt_to, nxt_cost] : edges[cur_to]) {",
            "            if (!used[nxt_to]) dfs(nxt_to);",
            "        }",
            "        order.push_back(cur_to);",
            "    }",
            "    void r_dfs(int cur_to, int component_idx) {",
            "        r_used[cur_to] = true;",
            "        component[cur_to] = component_idx;",
            "        for (auto& [nxt_to, nxt_cost] : r_edges[cur_to]) {",
            "            if (!r_used[nxt_to]) r_dfs(nxt_to, component_idx);",
            "        }",
            "    }",
            "",
            "    bool is_same(int u, int v) {return component[u] == component[v];}",
            "",
            "    vector<vector<int>> rebuild() {",
            "        int rebuild_vertex_size = *max_element(component.begin(), component.end()) + 1;",
            "        dbg(rebuild_vertex_size);",
            "        vector<vector<int>> res(rebuild_vertex_size);",
            "        set<pair<int, int>> connected;",
            "        for (int cv = 0; cv < vertex_size; cv++) {",
            "            for (auto& [nv, ncost] : edges[cv]) {",
            "                if (component[cv] != component[nv] and !connected.count({cv, nv})) {",
            "                    connected.insert({cv, nv});",
            "                    res[component[cv]].push_back(component[nv]);",
            "                }",
            "            }",
            "        }",
            "        return res;",
            "    }",
            "};",
        ],
        "description": ""
    },

    "LCS": {
        "prefix": "LCS",
        
        "body": [
            "int longest_common_sequence(string &S, string &T) {",
            "    int s_sz = S.size();",
            "    int t_sz = T.size();",
            "    vector<vector<int>> dp(s_sz + 1, vector<int>(t_sz + 1));",
            "    rep(i, s_sz) {",
            "        rep(j, t_sz) {",
            "            chmax(dp[i+1][j+1], dp[i+1][j]);",
            "            chmax(dp[i+1][j+1], dp[i][j+1]);",
            "            if (S[i] == T[j]) chmax(dp[i+1][j+1], dp[i][j] + 1);",
            "        }",
            "    }",
            "    return dp[s_sz][t_sz];",
            "}",
        ],
        "description": ""
    },
    
    "modint": {
        "prefix": "modint",
        
        "body": [
            "template <int MOD>",
            "struct ModInt {",
            "    static const int Mod = MOD;",
            "    unsigned x;",
            "    ModInt() : x(0) {}",
            "    ModInt(signed sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }",
            "    ModInt(signed long long sig) { x = sig < 0 ? sig % MOD + MOD : sig % MOD; }",
            "    int get() const { return (int)x; }",
            "    ModInt& operator+=(ModInt that) {",
            "        if ((x += that.x) >= MOD) x -= MOD;",
            "        return *this;",
            "    }",
            "    ModInt& operator-=(ModInt that) {",
            "        if ((x += MOD - that.x) >= MOD) x -= MOD;",
            "        return *this;",
            "    }",
            "    ModInt& operator*=(ModInt that) {",
            "        x = (unsigned long long)x * that.x % MOD;",
            "        return *this;",
            "    }",
            "    ModInt& operator/=(ModInt that) { return *this *= that.inv(); }",
            "    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }",
            "    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }",
            "    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }",
            "    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }",
            "    ModInt& operator++() {",
            "        x++;",
            "        if (x == MOD) x = 0;",
            "        return *this;",
            "    }",
            "    ModInt& operator--() {",
            "        if (x == 0) x = MOD;",
            "        x--;",
            "        return *this;",
            "    }",
            "    ModInt operator++(int) {",
            "        ModInt result = *this;",
            "        ++*this;",
            "        return result;",
            "    }",
            "    ModInt operator--(int) {",
            "        ModInt result = *this;",
            "        --*this;",
            "        return result;",
            "    }",
            "    bool operator==(ModInt that) const { return x == that.x; }",
            "    bool operator!=(ModInt that) const { return x != that.x; }",
            "    ModInt operator-() const {",
            "        ModInt t;",
            "        t.x = x == 0 ? 0 : Mod - x;",
            "        return t;",
            "    }",
            "",
            "    ModInt inv() const {",
            "        long long a = x, b = MOD, u = 1, v = 0;",
            "        while (b) {",
            "            long long t = a / b;",
            "            a -= t * b;",
            "            std::swap(a, b);",
            "            u -= t * v;",
            "            std::swap(u, v);",
            "        }",
            "        return ModInt(u);",
            "    }",
            "",
            "    ModInt pow(long long n) const {",
            "        assert(0 <= n);",
            "        ModInt x = *this, r = 1;",
            "        while (n) {",
            "            if (n & 1) r *= x;",
            "            x *= x;",
            "            n >>= 1;",
            "        }",
            "        return r;",
            "    }",
            "",
            "};",
            "template <int MOD>",
            "ostream& operator<<(ostream& st, const ModInt<MOD> a) {",
            "    st << a.get();",
            "    return st;",
            "};",
        ],
        "description": ""
    },



    "factorials": {
        "prefix": "factorials",
        
        "body": [
            "template <typename T, int FAC_MAX>",
            "struct Factorials {",
            "    vector<T> fac, ifac;",
            "    Factorials() {",
            "        fac.resize(FAC_MAX, 1);",
            "        ifac.resize(FAC_MAX, 1);",
            "        for (int i = 1; i < FAC_MAX; i++) {",
            "            fac[i] = fac[i - 1] * i;",
            "        }",
            "        ifac[FAC_MAX - 1] = T(1) / fac[FAC_MAX - 1];",
            "        for (int i = FAC_MAX - 2; i >= 1; i--) {",
            "            ifac[i] = ifac[i + 1] * T(i + 1);",
            "        }",
            "    }",
            "    T nPr(int n, int r) {",
            "        if (r < 0 || n < r) return T(0);",
            "        return fac[n] * ifac[n - r];",
            "    }",
            "    T nCr(int n, int r) {",
            "        if (r < 0 || n < r) return T(0);",
            "        return fac[n] * ifac[n - r] * ifac[r];",
            "    }",
            "    T nHr(int n, int r) {",
            "        if (n == 0 && r == 0) return T(1);",
            "        if (n <= 0 || r < 0) return 0;",
            "        return nCr(n + r - 1, r);",
            "    }  // nHk = (n+k-1)Ck : n is separator",
            "    T pairCombination(int n) {",
            "        if (n % 2 == 1) return T(0);",
            "        return fac[n] * ifac[n / 2] / (T(2) ^ (n / 2));",
            "    }",
            "    // combination of paris for n",
            "};",
            "",
            "// Factorials<mint, 40> comなどとして使用;",
        ],
        "description": ""
    },


    "Eratosthenes": {
        "prefix": "Erathosthenes",
        
        "body": [
            "/*  PrimeFact",
            "    init(N): 初期化。O(N log log N)",
            "    get(n): クエリ。素因数分解を求める。O(log n)",
            " */",
            "template <typename T>",
            "struct PrimeFact {",
            "    vector<T> spf;",
            "    PrimeFact(T N) { init(N); }",
            "    void init(T N) { // 前処理。spf を求める",
            "        spf.assign(N + 1, 0);",
            "        for (T i = 0; i <= N; i++) spf[i] = i;",
            "        for (T i = 2; i * i <= N; i++) {",
            "            if (spf[i] == i) {",
            "                for (T j = i * i; j <= N; j += i) {",
            "                    if (spf[j] == j) {",
            "                        spf[j] = i;",
            "                    }",
            "                }",
            "            }",
            "        }",
            "    }",
            "    map<T, T> get(T n) { // nの素因数分解を求める",
            "        map<T, T> m;",
            "        while (n != 1) {",
            "            m[spf[n]]++;",
            "            n /= spf[n];",
            "        }",
            "        return m;",
            "    }",
            "};",
            "",
        ],
        "description": ""
    },

    "compress": {
        "prefix": "compress",
        
        "body": [
            "/* compress",
            "    X を座標圧縮して書き換える",
            "    返り値: ソート済みの値(Xにどの値が存在するかを昇順に)",
            "    計算量: O(n log n)",
            "*/",
            "template <typename T> vector<T> compress(vector<T>& X) {",
            "    // ソートした結果を vals に",
            "    vector<T> vals = X;",
            "    sort(vals.begin(), vals.end());",
            "    // 隣り合う重複を削除(unique), 末端のゴミを削除(erase)",
            "    vals.erase(unique(vals.begin(), vals.end()), vals.end());",
            "    // 各要素ごとに二分探索で位置を求める",
            "    for (int i = 0; i < (int)X.size(); i++) {",
            "        X[i] = lower_bound(vals.begin(), vals.end(), X[i]) - vals.begin();",
            "    }",
            "    return vals;",
            "}",
            "/*",
            "    a = {6, 1, 7, 1, 2}",
            "    compress(a) = {1, 2, 6, 7}",
            "    a = {2, 0, 3, 0, 1}",
            "",
            "*/",
        ],
        "description": ""
    },

    "RunLength": {
        "prefix": "RunLength",
        
        "body": [
            "/* encode: ランレングス圧縮を行う",
            "*/",
            "vector<pair<char, int>> encode(const string& str) {",
            "    int n = (int)str.size();",
            "    vector<pair<char, int>> ret;",
            "    for (int l = 0; l < n;) {",
            "        int r = l + 1;",
            "        for (; r < n && str[l] == str[r]; r++) {};",
            "        ret.push_back({str[l], r - l});",
            "        l = r;",
            "    }",
            "    return ret;",
            "}",
            "",
            "/* decode: ランレングス圧縮の復元を行う",
            "*/",
            "string decode(const vector<pair<char, int>>& code) {",
            "    string ret = \"\";",
            "    for (auto p : code) {",
            "        for (int i = 0; i < p.second; i++) {",
            "            ret.push_back(p.first);",
            "        }",
            "    }",
            "    return ret;",
            "}",
        ],
        "description": ""
    },

    "FILL": {
        "prefix": "FILL",
        
        "body": [
            "// n次元配列の初期化。第２引数の型のサイズごとに初期化していく。",
            "template<typename A, size_t N, typename T>",
            "void Fill(A (&array)[N], const T &val){",
            "    std::fill( (T*)array, (T*)(array+N), val );",
            "}",
            "",
            "/*",
            "long long d[20][20];",
            "Fill( d, (long long)100 );    // 第２引数の型を配列の要素の型に合わせないとうまくいかない",
            "*/",
        ],
        "description": ""
    },

    "unionfind": {
        "prefix": "unionfind",
        
        "body": [
            "struct UnionFind {",
            "    vector<int> par, rank, siz;",
            "    // vector<bool> is_tree_impl;",
            "",
            "    // initialization",
            "    UnionFind(int N) : par(N, -1), rank(N, 0), siz(N, 1) ",
            "    // , is_tree_impl(N, true) ",
            "    {}",
            "",
            "    int root(int x) {",
            "        if (par[x] == -1) return x;",
            "        return par[x] = root(par[x]);",
            "    }",
            "    bool same(int x, int y) {",
            "        return root(x) == root(y);",
            "    }",
            "",
            "    void unite(int x, int y) {",
            "        int rx = root(x);",
            "        int ry = root(y);",
            "        if (rx == ry) {",
            "            // is_tree_impl[rx] = false;",
            "            return;",
            "        }",
            "        if (rank[rx] < rank[ry]) swap(rx, ry);",
            "        // if (same(rx, ry) or !is_tree_impl[ry]) is_tree_impl[rx] = false;",
            "        par[ry] = rx;",
            "        if (rank[rx] == rank[ry]) rank[rx]++;",
            "        siz[rx] += siz[ry];",
            "    }",
            "",
            "    int size(int x) {",
            "        return siz[root(x)];",
            "    }",
            "",
            "    // bool is_tree(int x) {",
            "    //     return is_tree_impl[root(x)];",
            "    // }",
            "};",
        ],
        "description": ""
    },



    "old_dijkstra": {
        "prefix": "old_dijkstra",
        "body": [
            "// vector<int> edgenum(MAX_N, -1);",
            "struct Edge {",
            "    int to;",
            "    ll cost;",
            "    // int id;",
            "};",
            " ",
            "using Graph = vector<vector<Edge> >;",
            " ",
            "using pli = pair<long long, int>;",
            "void dijkstra(const Graph &G, int s, vector<ll> &dis) {",
            "    assert(dis.size() == G.size());",
            " ",
            "    priority_queue<pli, vector<pli>, greater<pli>> pq;",
            "    dis[s] = 0;",
            "    pq.emplace(dis[s], s);",
            " ",
            "    while (!pq.empty()) {",
            "        auto [cur_d, cur_v] = pq.top(); pq.pop();",
            " ",
            "        if (dis[cur_v] != cur_d) continue;",
            " ",
            "        for (auto &[nxt_v, nxt_d] : G[cur_v]) {",
            "            if (dis[nxt_v] > dis[cur_v] + nxt_d) { // 最短距離候補",
            "                dis[nxt_v] = dis[cur_v] + nxt_d;",
            "                pq.push({dis[nxt_v], nxt_v});",
            "                // edgenum[e.to] = e.id;",
            "            }",
            "        }",
            "    }",
            "}",
        ],
        "description": ""
    },



    "cross_product": {
        "prefix": "cross_product",
        
        "body": [
            "struct pnt {",
            "    ll x; ll y;",
            "};",
            "ll cross_product(pnt vec_ab, pnt vec_cd){",
            "    // vec_ab(x1,y1)とvec_cd(x2,y2)の外積を計算",
            "    return vec_ab.x * vec_cd.y - vec_ab.y * vec_cd.x; ",
            "}",
        ],
        "description": ""
    },

    "is_intersect": {
        "prefix": "is_intersect",
        
        "body": [
            "struct pnt {",
            "    ll x; ll y;",
            "};",
            "ll cross_product(pnt vec_ab, pnt vec_cd){",
            "    // vec_ab(x1,y1)とvec_cd(x2,y2)の外積を計算",
            "    return vec_ab.x * vec_cd.y - vec_ab.y * vec_cd.x; ",
            "}",
            "bool is_intersect(pnt a, pnt b, pnt c, pnt d){",
            "    // 平面上の線分abと線分cdが交わるか判定",
            "    pnt vec_ab = {b.x - a.x, b.y - a.y};",
            "    pnt vec_ac = {c.x - a.x, c.y - a.y};",
            "    pnt vec_ad = {d.x - a.x, d.y - a.y};",
            "    pnt vec_cd = {d.x - c.x, d.y - c.y};",
            "    pnt vec_ca = {a.x - c.x, a.y - c.y};",
            "    pnt vec_cb = {b.x - c.x, b.y - c.y};",
            "    ll ab_ac = cross_product(vec_ab, vec_ac);",
            "    ll ab_ad = cross_product(vec_ab, vec_ad);",
            "    ll cd_ca = cross_product(vec_cd, vec_ca);",
            "    ll cd_cb = cross_product(vec_cd, vec_cb);",
            "    return ab_ac * ab_ad < 0 and cd_ca * cd_cb < 0;",
            "}",
        ],
        "description": ""
    },

    "weightedunionfind": {
        "prefix": "weightedunionfind",
        
        "body": [
            "template <typename T>",
            "struct WeightedUnionFind {",
            "    // diff_weight[i] := i と par[i] との差分",
            "    vector<int> par, rank;",
            "    vector<ll> diff_weight;",
            "",
            "    WeightedUnionFind(int N) {",
            "        par.assign(N, -1); ",
            "        rank.assign(N, 0); ",
            "        diff_weight.assign(N, 0);",
            "    }",
            "",
            "    int root(int x) {",
            "        if (par[x] == -1) return x;",
            "        int r = root(par[x]);",
            "        diff_weight[x] += diff_weight[par[x]]; // 親をさかのぼると同時に diff_weight の累積和を取る",
            "        return par[x] = r;",
            "    }",
            "",
            "    ll weight(int x) {",
            "        root(x);",
            "        return diff_weight[x];",
            "    }",
            "",
            "    void unite(int x, int y, ll z) {",
            "        z += weight(x) - weight(y);",
            "        int rx = root(x), ry = root(y);",
            "        if (rx == ry) return;",
            "        if (rank[rx] < rank[ry]) {",
            "            swap(rx, ry);",
            "            z *= -1;",
            "        }",
            "        if (rank[rx] == rank[ry]) rank[rx]++;",
            "        par[ry] = rx;",
            "        diff_weight[ry] = z;",
            "    }",
            "",
            "    bool same(int x, int y) {",
            "        return root(x) == root(y);",
            "    }",
            "};",
        ],
        "description": ""
    },

    "reversepolishnotation": {
        "prefix": "reversepolishnotation",
        
        "body": [
            "ll ReversePolishNotation(vector<string> vec) {",
            "    stack<ll> s;",
            "    fore (i, vec) {",
            "        if (i == \"+\" or i == \"-\" or i == \"*\") {",
            "            ll a1 = s.top(); s.pop();",
            "            ll a2 = s.top(); s.pop();",
            "            if (i == \"+\") s.push(a2 + a1);",
            "            else if (i == \"-\") s.push(a2 - a1);",
            "            else if (i == \"*\") s.push(a2 * a1);",
            "        }",
            "        else {",
            "            s.push(stoll(i));",
            "        }",
            "    }",
            "    return s.top();",
            "}",
        ],
        "description": ""
    },

    "modpow": {
        "prefix": "modpow",
        
        "body": [
            "ll modpow(ll x, ll n, ll mod) {",
            "    ll res = 1;",
            "    if (n == 0) return 1;",
            "    if (x == 0) return 0;",
            "    while (n) {",
            "        if (n & 1) {",
            "            res = res * x % mod;",
            "        }",
            "        x = x * x % mod; ",
            "        n >>= 1;",
            "    }",
            "    return res;",
            "}",
        ]
    },

    "kruscal": {
        "prefix": "kruscal",
        
        "body": [
            "struct UnionFind {",
            "    // par[i] := parent of i",
            "    vector<int> par, rank, siz;",
            "",
            "    // initialization",
            "    UnionFind(int N) : par(N, -1), rank(N, 0), siz(N, 1) {}",
            "",
            "    int root(int x) {",
            "        if (par[x] == -1) return x;",
            "        return par[x] = root(par[x]);",
            "    }",
            "",
            "    void unite(int x, int y) {",
            "        /* unite the trees where x and y belong */",
            "        int rx = root(x);",
            "        int ry = root(y);",
            "        if (rx == ry) return;",
            "        if (rank[rx] < rank[ry]) swap(rx, ry);",
            "        par[ry] = rx;",
            "        if (rank[rx] == rank[ry]) rank[rx]++;",
            "        siz[rx] += siz[ry];",
            "    }",
            "",
            "    bool same(int x, int y) {return root(x) == root(y);}",
            "    int size(int x) {return siz[root(x)];}",
            "};",
            "",
            "struct Edge {",
            "    int u; int v; ll cost;",
            "};",
            "bool comparefunc (const Edge &e1, const Edge &e2) {",
            "    return e1.cost < e2.cost;",
            "}",
            "",
            "struct Kruskal {",
            "    vector<Edge> edges;",
            "    int V;",
            "    ll sum_costs = 0;",
            "    vector<bool> used;",
            "    bool spanned = true;",
            "",
            "    Kruskal(const vector<Edge> &edges_, int V_) : edges(edges_), V(V_), used(V) {",
            "        init(); ",
            "    }",
            "",
            "    void init() {",
            "        sort(all(edges), comparefunc);",
            "        UnionFind UF(V);",
            "        fore (e, edges) {",
            "            if (!UF.same(e.u, e.v)) {",
            "                UF.unite(e.u, e.v);",
            "                used[e.u] = used[e.v] = true;",
            "                sum_costs += e.cost;",
            "            }",
            "        }",
            "        for (int i = 0; i < V; i++) {",
            "            if (!used[i]) {",
            "                spanned = false;",
            "                break;",
            "            }",
            "        }",
            "    }",
            "",
            "    bool is_spanned() {",
            "        return spanned;",
            "    }",
            "",
            "    ll sum() {",
            "        if (!is_spanned()) {",
            "            return numeric_limits<ll>::max();",
            "        }",
            "        return sum_costs;",
            "    }",
            "};",
            "",
        ],
        "description": ""
    },


    "topological_sort": {
        "prefix": "topological_sort",
        
        "body": [
            "vector<int> topological_sort(vector<vector<int> > &G, vector<int> &indegree) {",
            "    // 入力の段階で indegree をいじっておくことを忘れない！",
            "    vector<int> res;",
            "    int N = G.size(); // 頂点数",
            "    queue<int> que;",
            "    rep(i, N) {",
            "        if (indegree[i] == 0) que.push(i);",
            "    }",
            "    while (!que.empty()) {",
            "        int v = que.front(); que.pop();",
            "        res.push_back(v);",
            "        fore (vv, G[v]) {",
            "            indegree[vv]--;",
            "            if (indegree[vv] == 0) que.push(vv);",
            "        }",
            "    }",
            "    return res;",
            "}",
        ],
        "description": ""
    },

    "simple_primefact": {
        "prefix": "simple_primefact",
        
        "body": [
            "template <typename T>",
            "struct SimplePrimeFact {",
            "    bool is_prime(T M) {",
            "        if (M == 1) return false;",
            "        for (T i = 2; i * i <= M; i++) {",
            "            if (M % i == 0) {",
            "                return false;",
            "            }",
            "        }",
            "        return true;",
            "    }",
            "",
            "    vector<T> get_divisor(T M) {",
            "        vector<T> res;",
            "        for (T i = 1; i * i <= M; i++) {",
            "            if (M % i == 0) {",
            "                res.push_back(i);",
            "                if (i != M / i) {",
            "                    res.push_back(M / i);",
            "                }",
            "            }",
            "        }",
            "        return res;",
            "    }",
            "",
            "    vector<pair<T, int>> get_prime_factrization(T M) {",
            "        vector<pair<T, int>> res;",
            "        for (T i = 2; i * i <= M; i++) {",
            "            pll pu = {i, 0};",
            "            while (M % i == 0) {",
            "                M /= i;",
            "                pu.second++;",
            "            }",
            "            if (pu.second > 0) res.push_back(pu);",
            "        }",
            "        if (M != 1) res.push_back({M, 1});",
            "        return res;",
            "    }",
            "};",
        ],
        "description": ""
    },

    "rapid_primefact": {
        "prefix": "rapid_primefact",
        
        "body": [
            "/*  PrimeFact",
            "    init(N): 初期化。O(N log log N)",
            "    get(n): クエリ。素因数分解を求める。O(log n)",
            " */",
            "struct RapidPrimeFact {",
            "    vector<int> spf;",
            "    RapidPrimeFact(int N) { init(N); }",
            "    void init(int N) { // 前処理。spf を求める",
            "        spf.assign(N + 1, 0);",
            "        for (int i = 0; i <= N; i++) spf[i] = i;",
            "        for (int i = 2; i * i <= N; i++) {",
            "            if (spf[i] == i) {",
            "                for (int j = i * i; j <= N; j += i) {",
            "                    if (spf[j] == j) {",
            "                        spf[j] = i;",
            "                    }",
            "                }",
            "            }",
            "        }",
            "    }",
            "",
            "    bool is_prime(int n) {",
            "        if (n == 1) return false;",
            "        return spf[n] == n;",
            "    }",
            "",
            "    vector<pair<int, int>> get_prime_factorization(int n) { ",
            "        vector<pair<int, int>> res;",
            "        pair<int, int> cur = {spf[n], 0};",
            "        while (n != 1) {",
            "            if (spf[n] == cur.first) {",
            "                cur.second++;",
            "            } else {",
            "                res.push_back(cur);",
            "                cur = {spf[n], 1};",
            "            }",
            "            n /= spf[n];",
            "        }",
            "        res.push_back(cur);",
            "        return res;",
            "    }",
            "};",
        ],
        "description": ""
    },

    "combination": {
        "prefix": "combination",
        
        "body": [
            "const int MAX_N = 1000100;",
            "long long fact[MAX_N], fact_inv[MAX_N], inv[MAX_N];",
            "",
            "void combInit() {",
            "    fact[0] = fact[1] = 1;",
            "    fact_inv[0] = fact_inv[1] = 1;",
            "    inv[1] = 1;",
            "    for (int i = 2; i < MAX_N; i++) {",
            "        fact[i] = fact[i - 1] * i % MOD;",
            "        inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;",
            "        fact_inv[i] = fact_inv[i - 1] * inv[i] % MOD;",
            "    }",
            "}",
            "",
            "long long comb(int n, int k) {",
            "    if (n < k) return 0;",
            "    if (n < 0 or k < 0) return 0;",
            "    return fact[n] * (fact_inv[k] * fact_inv[n - k] % MOD) % MOD;",
            "}",
            "",
            "long long rep_comb(int n, int k) {",
            "    return comb(n + k - 1, k);",
            "}",
        ],
        "description": ""
    },

    "fenwick_tree": {
        "prefix": "fenwick_tree",
        
        "body": [
            "template <typename T>",
            "struct FenwickTree {",
            "    const T INF = numeric_limits<T>::max();",
            "    int N; // 元の配列のサイズ",
            "    int n;",
            "    vector<T> dat;",
            "    FenwickTree(int n_) : N(n_), n(), dat(n_ * 4, 0) {",
            "        int x = 1;",
            "        while (n_ > x) {",
            "            x *= 2;",
            "        }",
            "        n = x;",
            "    }",
            "",
            "    // a[i] に x を加算",
            "    void add(int i, T x) {",
            "        assert(0 <= i && i < N);",
            "        i++;",
            "        while (i <= n) {",
            "            dat[i] += x;",
            "            i += i & -i;",
            "        }",
            "    }",
            "",
            "    // a[0, i) (半開区間) の和 (O(log N))",
            "    T sum(int i) {",
            "        assert(0 <= i && i <= N);",
            "        T s = 0;",
            "        while (i > 0) {",
            "            s += dat[i];",
            "            i -= i & -i;",
            "        }",
            "        return s;",
            "    }",
            "",
            "    // a_l + ... + a_{r-1}",
            "    ",
            "    // a [l, r) の和 (半開区間) O(log N)",
            "    T sum(int l, int r) {",
            "        assert(0 <= l && l <= r && r <= N);",
            "        return sum(r) - sum(l);",
            "    }",
            "",
            "};",
        ],
        "description": ""
    },


    "segment_tree": {
        "prefix": "segment_tree",
        
        "body": [
            "template <typename X>",
            "struct SegTree {",
            "    using FX = function<X(X, X)>; // X•X -> X となる関数の型",
            "    int n;",
            "    FX fx;",
            "    FX update_func;",
            "    const X ex;",
            "    vector<X> dat;",
            "    // SegTree<X>(n,fx,ex): モノイド(集合X, 二項演算fx, 単位元ex)についてサイズnで構築",
            "    SegTree(int n_, FX fx_, X ex_) : n(), fx(fx_), ex(ex_), dat(n_ * 4, ex_) {",
            "        int x = 1;",
            "        while (n_ > x) {",
            "            x *= 2;",
            "        }",
            "        n = x;",
            "    }",
            "",
            "    // set(int i, X x), build(): i番目の要素をxにセット。まとめてセグ木を構築する。O(n)",
            "    void set(int i, X x) { dat[i + n - 1] = x; }",
            "    void build() {",
            "        for (int k = n - 2; k >= 0; k--) dat[k] = fx(dat[2 * k + 1], dat[2 * k + 2]);",
            "    }",
            "",
            "    // update(i,x): i 番目の要素を x に更新。O(log(n))",
            "    void update(int i, X x) {",
            "        i += n - 1;",
            "        /* 一点更新とか加算とかに応じて dat[i] に x をどう作用させるか変える */",
            "        dat[i] = x;",
            "        while (i > 0) {",
            "            i = (i - 1) / 2;  // parent",
            "            dat[i] = fx(dat[i * 2 + 1], dat[i * 2 + 2]);",
            "        }",
            "    }",
            "",
            "    // query(a,b): [a,b) 全てにfxを作用させた値を取得。O(log(n))",
            "    X query(int a, int b) { return query_sub(a, b, 0, 0, n); }",
            "    X query_sub(int a, int b, int k, int l, int r) {",
            "        if (r <= a || b <= l) {",
            "            return ex;",
            "        } else if (a <= l && r <= b) {",
            "            return dat[k];",
            "        } else {",
            "            X value_left = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);",
            "            X value_right = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);",
            "            return fx(value_left, value_right);",
            "        }",
            "    }",
            "};",
        ],
        "description": ""
    },

    "rotate_cloclwise": {
        "prefix": "rotate_cloclwise",
        "body": [
            "template<typename T> vector<vector<T>> rotate_clockwise(vector<vector<T>> g) {",
            "    int n = g.size();",
            "    int m = g[0].size();",
            "    vector<vector<T>> res(m, vector<T>(n));",
            "    rep(i, 0, n) rep(j, 0, m) res[j][n - i - 1] = g[i][j];",
            "    return res;",
            "}",
        ],
        "description": ""
    },

    "unionfind_2d": {
        "prefix": "unionfind_2d",
        
        "body": [
            "struct UnionFind2D {",
            "    vector<vector<pair<int, int>>> par;",
            "    vector<vector<int>> rank, siz;",
            "",
            "    UnionFind2D(int H, int W) : ",
            "        par(H, vector<pair<int, int>>(W, {-1, -1})), ",
            "        rank(H, vector<int>(W)), siz(H, vector<int>(W)) {}",
            "",
            "    pair<int, int> root(int x, int y) {",
            "        if (par[x][y] == make_pair(-1, -1)) {",
            "            return {x, y};",
            "        }",
            "        return par[x][y] = root(par[x][y].first, par[x][y].second);",
            "    }",
            "",
            "    void unite(int cx, int cy, int nx, int ny) {",
            "        pair<int, int> rc = root(cx, cy);",
            "        pair<int, int> rn = root(nx, ny);",
            "        if (rc == rn) {",
            "            return;",
            "        }",
            "        if (rank[rc.first][rc.second] < rank[rn.first][rn.second]) {",
            "            swap(rc, rn);",
            "        }",
            "        par[rn.first][rn.second] = rc;",
            "        if (rank[rc.first][rc.second] == rank[rn.first][rn.second]) {",
            "            rank[rc.first][rc.second]++;",
            "        }",
            "        siz[rc.first][rc.second] += siz[rn.first][rn.second];",
            "    }",
            "",
            "    bool same(int cx, int cy, int nx, int ny) {",
            "        return root(cx, cy) == root(nx, ny);",
            "    }",
            "",
            "    int size(int cx, int cy) {",
            "        return siz[root(cx, cy).first][root(cx, cy).second];",
            "    }",
            "};",
        ],
        "description": ""
    },


    "doubling": {
        "prefix": "doubling",
        
        "body": [
            "struct Doubling {",
            "    int N;",
            "    vector<int> nxt;",
            "    vector<vector<int>> doubling;",
            "    const int logK = 62;",
            "    ",
            "    Doubling(const vector<int>& nxt_) : ",
            "        nxt(nxt_), N(nxt_.size()) ",
            "    {",
            "        doubling.assign(logK, vector<int>(N));",
            "        init();",
            "    }",
            "",
            "    void init() {",
            "        // 初期化 O(N logK)",
            "        for (int i = 0; i < N; i++) {",
            "            doubling[0][i] = nxt[i];",
            "        }",
            "        for (int k = 0; k < logK - 1; k++) {",
            "            for (int i = 0; i < N; i++) {",
            "                doubling[k+1][i] = doubling[k][doubling[k][i]];",
            "            }",
            "        }",
            "    }",
            "",
            "    int query(int now, long long K) {",
            "        // クエリ O(log K)",
            "        for (int k = 0; K > 0; k++) {",
            "            if (K & 1) now = doubling[k][now];",
            "            K = K >> 1;",
            "        }",
            "        return now;",
            "    }",
            "};",
        ],
        "description": ""
    },

    "File Header 1": {
        "prefix": "yukihira_pot",
        "description": "Output a file header with the file name and date",
        "body": [
            "$BLOCK_COMMENT_START",
            "    author: yukihira_pot",
            "    date: $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE",
            "$BLOCK_COMMENT_END",
        ],
    },

    "File Header 2": {
        "prefix": "magochansan",
        "description": "Output a file header with the file name and date",
        "body": [
            "$BLOCK_COMMENT_START",
            "    author: magochansan",
            "    date: $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE",
            "$BLOCK_COMMENT_END",
        ],
    },

    "range_fenwick_tree": {
        "prefix": "range_fenwick_tree",
        
        "body": [
            "// 0-indexed で使えます",
            "template <typename T>",
            "struct FenwickTreeRange {",
            "    int n;             // 要素数",
            "    vector<T> bit[2];  // データの格納先",
            "    FenwickTreeRange(int n_) { init(n_); }",
            "    void init(int n_) {",
            "        n = n_ + 1;",
            "        for (int p = 0; p < 2; p++) bit[p].assign(n, 0);",
            "    }",
            "",
            "    // add(l,r,x): [l,r) に x を加算",
            "    void add(int l, int r, T x) {",
            "        l++;",
            "        r++;",
            "        add_sub(0, l, -x * (l - 1));",
            "        add_sub(0, r, x * (r - 1));",
            "        add_sub(1, l, x);",
            "        add_sub(1, r, -x);",
            "    }",
            "",
            "    // sum(i): a_1 + a_2 + ... + a_i を計算",
            "    T sum(int i) {",
            "        i++;",
            "        return sum_sub(0, i) + sum_sub(1, i) * i;",
            "    }",
            "",
            "    // [l,r) の区間和を取得",
            "    T query(int l, int r) {",
            "        l++;",
            "        r++;",
            "        return query_sub(r - 1) - query_sub(l - 1);",
            "    }",
            "",
            "   private:",
            "    void add_sub(int p, int i, T x) {",
            "        for (int idx = i; idx < n; idx += (idx & -idx)) {",
            "            bit[p][idx] += x;",
            "        }",
            "    }",
            "",
            "    T sum_sub(int p, int i) {",
            "        T s(0);",
            "        for (int idx = i; idx > 0; idx -= (idx & -idx)) {",
            "            s += bit[p][idx];",
            "        }",
            "        return s;",
            "    }",
            "",
            "    T query_sub(int i) { return sum_sub(0, i) + sum_sub(1, i) * i; }",
            "};",
        ],
        "description": ""
    },

    "dfs_bfs_tree": {
        "prefix": "dfs_bfs_tree",
        
        "body": [
            "struct DfsBfsTree {",
            "    vector<vector<int>> edges;",
            "    int n;",
            "    DfsBfsTree(vector<vector<int>> &edges_) : edges(edges_), n(edges_.size()) {}",
            "",
            "    void dfs_impl(int cur, vector<bool> &seen, vector<pair<int, int>> &output, ",
            "    const vector<vector<int>> &edges) {",
            "        for (auto& nxt : edges[cur]) {",
            "            if (!seen[nxt]) {",
            "                seen[nxt] = true;",
            "                output.push_back({cur, nxt});",
            "                dfs_impl(nxt, seen, output, edges);",
            "            }",
            "        }",
            "    }",
            "",
            "    void bfs_impl(int cur, vector<bool> &seen, vector<pair<int, int>> &output, ",
            "    const vector<vector<int>> &edges) {",
            "        queue<int> que;",
            "        que.push(cur);",
            "        seen[cur] = true;",
            "        while (que.size()) {",
            "            int now = que.front();",
            "            que.pop();",
            "            for (auto& nxt : edges[now]) {",
            "                if (!seen[nxt]) {",
            "                    seen[nxt] = true;",
            "                    output.push_back({now, nxt});",
            "                    que.push(nxt);",
            "                }",
            "            }",
            "        }",
            "    }",
            "",
            "    // dfs 木を (現頂点, 次頂点) の pair で表現",
            "    vector<pair<int, int>> dfs(int start) {",
            "        vector<bool> seen(n);",
            "        vector<pair<int, int>> res;",
            "        seen[start] = true;",
            "        dfs_impl(start, seen, res, edges);",
            "        return res;",
            "    }",
            "",
            "    // bfs 木を (現頂点, 次頂点) の pair で表現",
            "    vector<pair<int, int>> bfs(int start) {",
            "        vector<bool> seen(n);",
            "        vector<pair<int, int>> res;",
            "        bfs_impl(start, seen, res, edges);",
            "        return res;",
            "    }",
            "};",
        ],
        "description": ""
    },

    "bipartite_graph": {
        "prefix": "bipartite_graph",
        
        "body": [
            "struct UnionFind {",
            "    vector<int> par, rank, siz;",
            "    // vector<bool> is_tree_impl;",
            "",
            "    // initialization",
            "    UnionFind(int N) : par(N, -1), rank(N, 0), siz(N, 1) ",
            "    // , is_tree_impl(N, true) ",
            "    {}",
            "",
            "    int root(int x) {",
            "        if (par[x] == -1) return x;",
            "        return par[x] = root(par[x]);",
            "    }",
            "    bool same(int x, int y) {",
            "        return root(x) == root(y);",
            "    }",
            "",
            "    void unite(int x, int y) {",
            "        int rx = root(x);",
            "        int ry = root(y);",
            "        if (rx == ry) {",
            "            // is_tree_impl[rx] = false;",
            "            return;",
            "        }",
            "        if (rank[rx] < rank[ry]) swap(rx, ry);",
            "        // if (same(rx, ry) or !is_tree_impl[ry]) is_tree_impl[rx] = false;",
            "        par[ry] = rx;",
            "        if (rank[rx] == rank[ry]) rank[rx]++;",
            "        siz[rx] += siz[ry];",
            "    }",
            "",
            "    int size(int x) {",
            "        return siz[root(x)];",
            "    }",
            "",
            "    // bool is_tree(int x) {",
            "    //     return is_tree_impl[root(x)];",
            "    // }",
            "};",
            "",
            "struct BipartiteGraph : UnionFind {",
            "    // https://ei1333.github.io/algorithm/union-find.html より",
            "    // validation : https://atcoder.jp/contests/abc282/submissions/37365726",
            "",
            "    vector<int> color;",
            "    int v;",
            "    BipartiteGraph(int v_) : v(v_), color(v_ + v_, -1), UnionFind(v_ + v_) {}",
            "",
            "    bool bipartite_graph_coloring() {",
            "        // 隣接頂点を同じ色にするとき : unite(u, v); unite(u + N, v + N);",
            "        // 隣接頂点を違う色にするとき : unite(u, v + N); unite(u + N, v);",
            "        for (int i = 0; i < v; i++) {",
            "            int a = root(i);",
            "            int b = root(i + v);",
            "            if (a == b) return false;",
            "            if (color[a] < 0) {",
            "                color[a] = 0; ",
            "                color[b] = 1;",
            "            }",
            "        }",
            "        return true;",
            "    }",
            "",
            "    bool get_color(int k) { return bool(color[root(k)]); }",
            "};",
        ],
        "description": ""
    },

    "make_sentinel": {
        "prefix": "make_sentinel",
        
        "body": [
            "/* ",
            "    2次元 vector : A の周囲 4 辺に番兵を設定します",
            "    縦横のサイズを +2 します ",
            "*/",
            "template<typename T>",
            "vector<vector<T>> make_sentinel(vector<vector<T>> &A, int& H, int& W, T sentinel) {",
            "    vector<vector<T>> res(H + 2);",
            "    for (int j = 0; j < W + 2; j++) {",
            "        res[0].push_back(sentinel);",
            "    }",
            "    for (int i = 0; i < H; i++) {",
            "        res[i + 1].push_back(sentinel);",
            "        for (int j = 0; j < W; j++) {",
            "            res[i + 1].push_back(A[i][j]);",
            "        }",
            "        res[i + 1].push_back(sentinel);",
            "    }",
            "    for (int j = 0; j < W + 2; j++) {",
            "        res[H + 1].push_back(sentinel);",
            "    }",
            "    // H += 2;",
            "    // W += 2;",
            "    return res;",
            "}",
        ],
        "description": ""
    },

    "z_algorithm": {
        "prefix": "z_algorithm",
        
        "body": [
            "/*",
            "    Z 配列 (Z[i] := S と S[i:] の最長共通接頭辞) を作成",
            "    O(|S|)",
            "*/",
            "template <typename T> ",
            "vector<int> z_algorithm(const vector<T> &S) {",
            "    // https://qiita.com/Pro_ktmr/items/16904c9570aa0953bf05 より",
            "    int N = (int)S.size();",
            "    // Z 配列 (Z[i] := S と S[i:] の最長共通接頭辞)",
            "    vector<int> Z(N); ",
            "    Z[0] = S.size();",
            "    // i := Z 配列のインデックス",
            "    // j := Z[i] に入るべき値",
            "    int i = 1, j = 0;",
            "    while (i < N) {",
            "        // Z[i] を計算, 伸ばしていく",
            "        while (i + j < N && S[j] == S[i + j]) j++;",
            "        Z[i] = j;",
            "",
            "        if (j == 0) {",
            "            i++;",
            "            continue;",
            "        }",
            "",
            "        // 計算した Z[i] の結果を再利用する",
            "        // i より先の文字列 S[i + k : ] について, ",
            "        // Z[i + k] がすぐに計算できるか考える",
            "        // もし j (= Z[i]) が Z[k] + k より小なら、そのまま使える",
            "        int k = 1;",
            "        while (k < j && k + Z[k] < j) {",
            "            Z[i + k] = Z[k];",
            "            k++;",
            "        }",
            "",
            "        // 伸ばした分だけ i と j を更新",
            "        i += k, j -= k;",
            "    }",
            "",
            "    return Z;",
            "} ",
            "",
            "/*",
            "    Z 配列 (Z[i] := S と S[i:] の最長共通接頭辞) を作成",
            "    O(|S|)",
            "*/",
            "vector<int> z_algorithm(const string &S) {",
            "    int N = S.size();",
            "    vector<char> S_v(N);",
            "    for (int i = 0; i < N; i++) S_v[i] = S[i];",
            "    return z_algorithm(S_v);",
            "}",
        ],
        "description": ""
    },

    "rolling_hash": {
        "prefix": "rolling_hash",
        
        "body": [
            "struct RollingHash {",
            "    // Ref : https://github.com/Capobmb/CPcpp_library/blob/main/RollingHash.cpp",
            "    int n;",
            "",
            "    using ull = unsigned long long;",
            "    static constexpr ull MOD = (1UL << 61) - 1;",
            "    // static constexpr int base = 9973;",
            "    static inline const ull base = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();;",
            "    std::vector<ull> hash, power;",
            "",
            "    // a*b mod 2^61-1 (最後にModを取らない) / note: result < 4*MOD",
            "    static ull mul(ull a, ull b) {",
            "        static constexpr ull MASK30 = (1UL << 30) - 1;",
            "        static constexpr ull MASK31 = (1UL << 31) - 1;",
            "        ull au = a >> 31;",
            "        ull ad = a & MASK31;",
            "        ull bu = b >> 31;",
            "        ull bd = b & MASK31;",
            "        ull mid = ad * bu + au * bd;",
            "        ull midu = mid >> 30;",
            "        ull midd = mid & MASK30;",
            "        return au * bu * 2 + midu + (midd << 31) + ad * bd;",
            "    }",
            "",
            "    // X mod 2^61-1",
            "    static ull take_mod(ull x) {",
            "        static constexpr ull MASK61 = MOD;",
            "        ull xu = x >> 61;",
            "        ull xd = x & MASK61;",
            "        ull res = xu + xd;",
            "        if (res >= MOD) res -= MOD;",
            "        return res;",
            "    }",
            "",
            "    RollingHash(const std::string &s) : n(s.size()), hash(n+1), power(n+1) {",
            "        hash[0] = 0;",
            "        power[0] = 1;",
            "        for(int j = 0; j < n; j++) {",
            "            power[j+1] = take_mod(mul(power[j], base));",
            "            hash[j+1] = take_mod(mul(hash[j], base) + s[j]);",
            "        }",
            "    }",
            "",
            "    // get hash of S[l:r) in O(1)",
            "    ull gethash(int l, int r) const {",
            "        static constexpr ull POSITIVIZER = MOD << 2;",
            "        return take_mod(hash[r] + POSITIVIZER - mul(hash[l], power[r-l]));",
            "    }",
            "",
            "    // return S[l1:r1) == S[l2:r2) in O(1)",
            "    bool is_same(int l1, int r1, int l2, int r2) const {",
            "        return gethash(l1, r1) == gethash(l2, r2);",
            "    }",
            "",
            "    // get length of LCP of S[l1:r1) and S[l2:r2) in O(logN)",
            "    int get_lcp(int l1, int r1, int l2, int r2) const {",
            "        int len = std::min(r1 - l1, r2 - l2);",
            "        int ok = 0, ng = len + 1, mid{};",
            "        while(ng - ok > 1) {",
            "            mid = (ok + ng) >> 1;",
            "            (is_same(l1, l1 + mid, l2, l2 + mid) ? ok : ng) = mid;",
            "        }",
            "        return ok;",
            "    }",
            "",
            "    // concatenate hash of S[l1:r1) and S[l2:r2) in this order",
            "    ull concat(int l1, int r1, int l2, int r2) const {",
            "        auto lh = gethash(l1, r1);",
            "        auto rh = gethash(l2, r2);",
            "        auto res = take_mod(mul(lh, power[r2-l2])) + rh;",
            "        if(res >= MOD) res -= MOD;",
            "        return res;",
            "    }",
            "};",
            "using RH = RollingHash;",
            "unsigned long long concat(RH& a, int l1, int r1, RH& b, int l2, int r2) {",
            "    auto ah = a.gethash(l1, r1);",
            "    auto bh = b.gethash(l2, r2);",
            "    auto res = RH::take_mod(RH::mul(ah, b.power[r2 - l2])) + bh;",
            "    if(res >= RH::MOD) res -= RH::MOD;",
            "    return res;",
            "}",
            "int get_lcp(RH& a, int l1, int r1, RH& b, int l2, int r2) {",
            "    int ok = 0, ng = std::min(r1 - l1, r2 - l2) + 1, mid{};",
            "    while(ng - ok > 1) {",
            "        mid = (ok + ng) >> 1;",
            "        (a.gethash(l1, l1 + mid) == b.gethash(l2, l2 + mid) ? ok : ng) = mid;",
            "    }",
            "    return ok;",
            "}",
            "// s[l1, r1) < t[l2, r2)",
            "bool is_less(string& s, string& t, RH& sh, int l1, int r1, RH& th, int l2, int r2) {",
            "    int lcp_len = get_lcp(sh, l1, r1, th, l2, r2);",
            "    if(lcp_len == r1 - l1 || lcp_len == r2 - l2) return r1 - l1 < r2 - l2;",
            "    return s[l1 + lcp_len] < t[l2 + lcp_len];",
            "}",
            "// s[l1, r1) > t[l2, r2)",
            "bool is_greater(string& s, string& t, RH& sh, int l1, int r1, RH& th, int l2, int r2) {",
            "    return !is_less(s, t, sh, l1, r1, th, l2, r2);",
            "}",
        ],
        "description": ""
    },


    "trie_basic": {
        "prefix": "trie_basic",
        
        "body": [
            "/// @brief Trie 木, insert (単語の挿入), search (単語の検索)",
            "/// @tparam alphabet_size 文字列の種類数 (26など)",
            "/// @tparam base 文字列の先頭 (aなど)",
            "template <int alphabet_size, char base>",
            "struct Trie {",
            "    struct Node {",
            "        vector<int> children_ids;  // 1. 子頂点の id たち",
            "        int node_char;             // 2. その頂点の文字 : (int)(その文字 - base)",
            "        bool is_endpoint;          // 3. その頂点で終了するか",
            "",
            "        // optional",
            "        int has_common;            // 4. その頂点をどれだけの文字列が共有しているか",
            "",
            "        Node(int node_char_)",
            "            : node_char(node_char_), is_endpoint(0), has_common(0) {",
            "            children_ids.assign(alphabet_size, -1);",
            "        }",
            "    };",
            "",
            "    vector<Node> nodes;",
            "    int root;",
            "    Trie() : root(0) { nodes.push_back(Node(root)); }",
            "",
            "    void insert(const string& word) {",
            "        int node_id = 0;  // 頂点から下っていく",
            "        for (auto c : word) {",
            "            int cur_char = (int)(c - base);",
            "",
            "            int& next_id = nodes[node_id].children_ids[cur_char];",
            "            if (next_id == -1) {  // 次の頂点が存在しない場合",
            "                next_id = (int)nodes.size();",
            "                nodes.push_back(Node(cur_char));",
            "            }",
            "            nodes[node_id].has_common++;  // optional : 4",
            "            node_id = next_id;            // 次頂点へ",
            "        }",
            "        nodes[node_id].has_common++;  // optional : 4",
            "        nodes[node_id].is_endpoint = true;",
            "    }",
            "",
            "    bool search(const string& word) {",
            "        int node_id = 0;  // 頂点から下っていく",
            "        for (auto c : word) {",
            "            int cur_char = (int)(c - base);",
            "",
            "            int next_id = nodes[node_id].children_ids[cur_char];",
            "            if (next_id == -1) return false;",
            "            node_id = next_id;  // 次頂点へ",
            "        }",
            "        return nodes[node_id].is_endpoint;",
            "    }",
            "",
            "    // 最大の LCP を求める",
            "    int get_max_lcp(const string& word) {",
            "        int ret = 0;",
            "        int node_id = 0;",
            "        for (auto c : word) {",
            "            int cur_char = (int)(c - base);",
            "",
            "            int next_id = nodes[node_id].children_ids[cur_char];",
            "            if (nodes[next_id].has_common == 1)",
            "                return ret;  // 自分自身だけがその頂点を占有",
            "            ret++;",
            "",
            "            node_id = next_id;  // 次頂点へ",
            "        }",
            "        return ret;",
            "    }",
            "};",
        ],
        "description": ""
    },


    "trie": {
        "prefix": "trie_ext",
        
        "body": [
            "/* Trie 木： 文字の種類 (char_size) 、int型で0に対応する文字 (base)",
            "    insert(word): 単語 word を Trie 木に挿入する",
            "    search(word): 単語 word が Trie 木にあるか判定する",
            "    start_with(prefix):  prefix が一致する単語が Trie 木にあるか判定する",
            "    count(): 挿入した単語の数を返す",
            "    size(): Trie 木の頂点数を返す",
            "    計算量: insert, search, get_lcp: O(M)（ M は単語の長さ）",
            "*/",
            "template <int char_size, int base>",
            "struct Trie {",
            "    struct Node {            // 頂点を表す構造体",
            "        vector<int> next;    // 子の頂点番号を格納。存在しなければ -1",
            "        vector<int> accept;  // 末端がこの頂点になる単語の word_id を保存",
            "        int c;               // base からの間隔を int 型で表現したもの",
            "        int common;          // いくつの単語がこの頂点を共有しているか",
            "        Node(int c_) : c(c_), common(0) {",
            "            next.assign(char_size, -1);",
            "        }",
            "    };",
            "",
            "    vector<Node> nodes;  // Trie 木本体",
            "    int root;",
            "    Trie() : root(0) {",
            "        nodes.push_back(Node(root));",
            "    }",
            "",
            "    // 単語の挿入",
            "    void insert(const string &word, int word_id) {",
            "        int node_id = 0;",
            "        for (int i = 0; i < (int)word.size(); i++) {",
            "            int c = (int)(word[i] - base);",
            "            int &next_id = nodes[node_id].next[c];",
            "            if (next_id == -1) {  // 次の頂点が存在しなければ追加",
            "                next_id = (int)nodes.size(); // 今見ている頂点に next_id を追加",
            "                nodes.push_back(Node(c));",
            "            }",
            "            ++nodes[node_id].common;",
            "            node_id = next_id;",
            "        }",
            "        ++nodes[node_id].common;",
            "        nodes[node_id].accept.push_back(word_id);",
            "    }",
            "    void insert(const string &word) {",
            "        insert(word, nodes[0].common);",
            "    }",
            "",
            "    // 単語と prefix の検索",
            "    bool search(const string &word, bool prefix = false) {",
            "        int node_id = 0;",
            "        for (int i = 0; i < (int)word.size(); i++) {",
            "            int c = (int)(word[i] - base);",
            "            int &next_id = nodes[node_id].next[c];",
            "            if (next_id == -1) {  // 次の頂点が存在しなければ終了",
            "                return false;",
            "            }",
            "            node_id = next_id;",
            "        }",
            "        return (prefix) ? true : nodes[node_id].accept.size() > 0;",
            "    }",
            "",
            "    // prefix を持つ単語が存在するかの検索",
            "    bool start_with(const string &prefix) {",
            "        return search(prefix, true);",
            "    }",
            "",
            "    // 格納されている単語について、他の単語との最大共通接尾辞長",
            "    int get_max_lcp(const string &word) {",
            "        int node_id = 0;",
            "        for (int i = 0; i < (int)word.size(); i++) {",
            "            int c = (int)(word[i] - base);",
            "            int& next_id = nodes[node_id].next[c];",
            "            if (nodes[next_id].common == 1) return i;",
            "            node_id = next_id;",
            "        }",
            "        return (int)word.size();",
            "    }",
            "",
            "    // 挿入した単語の数",
            "    int count() const {",
            "        return (nodes[0].common);",
            "    }",
            "    // Trie 木のノード数",
            "    int size() const {",
            "        return ((int)nodes.size());",
            "    }",
            "};",
        ],
        "description": ""
    },

    "accumulate_2d": {
        "prefix": "accumulate_2d",
        
        "body": [
            "template <typename T>",
            "struct Accumulate2D {",
            "    int h, w;",
            "    vector<vector<T>> accum;",
            "    Accumulate2D(vector<vector<T>>& _field) {",
            "        h = _field.size();",
            "        w = _field[0].size();",
            "        accum.resize(h + 1, vector<T>(w + 1, 0));",
            "        init(_field);",
            "    }",
            "",
            "    void init(vector<vector<T>>& _field) {",
            "        for (int i = 0; i < h; i++) {",
            "            for (int j = 0; j < w; j++) {",
            "                accum[i + 1][j + 1] +=",
            "                    accum[i + 1][j] + accum[i][j + 1] - accum[i][j] + _field[i][j];",
            "            }",
            "        }",
            "    }",
            "",
            "    /// @brief [ i1, i2 ), [ j1, j2 ) の範囲にある和を求める",
            "    T query(int i1, int i2, int j1, int j2) {",
            "        return accum[i2][j2] - accum[i1][j2] - accum[i2][j1] + accum[i1][j1];",
            "    }",
            "};",
        ],
        "description": ""
    },

    "lazy_segment_tree": {
        "prefix": "lazy_segment_tree",
        
        "body": [
            "// Ref : https://atcoder.github.io/ac-library/document_ja/lazysegtree.html",
            "namespace internal {",
            "",
            "// @param n `0 <= n`",
            "// @return minimum non-negative `x` s.t. `n <= 2**x`",
            "int ceil_pow2(int n) {",
            "    int x = 0;",
            "    while ((1U << x) < (unsigned int)(n)) x++;",
            "    return x;",
            "}",
            "",
            "// @param n `1 <= n`",
            "// @return minimum non-negative `x` s.t. `(n & (1 << x)) != 0`",
            "int bsf(unsigned int n) {",
            "#ifdef _MSC_VER",
            "    unsigned long index;",
            "    _BitScanForward(&index, n);",
            "    return index;",
            "#else",
            "    return __builtin_ctz(n);",
            "#endif",
            "}",
            "",
            "}  // namespace internal",
            "",
            "template <class S, S (*op)(S, S), S (*e)(), class F, S (*mapping)(F, S),",
            "          F (*composition)(F, F), F (*id)()>",
            "struct LazySegTree {",
            "   public:",
            "    LazySegTree() : LazySegTree(0) {}",
            "    LazySegTree(int n) : LazySegTree(std::vector<S>(n, e())) {}",
            "    LazySegTree(const std::vector<S>& v) : _n(int(v.size())) {",
            "        log = internal::ceil_pow2(_n);",
            "        size = 1 << log;",
            "        d = std::vector<S>(2 * size, e());",
            "        lz = std::vector<F>(size, id());",
            "        for (int i = 0; i < _n; i++) d[size + i] = v[i];",
            "        for (int i = size - 1; i >= 1; i--) {",
            "            update(i);",
            "        }",
            "    }",
            "",
            "    void set(int p, S x) {",
            "        assert(0 <= p && p < _n);",
            "        p += size;",
            "        for (int i = log; i >= 1; i--) push(p >> i);",
            "        d[p] = x;",
            "        for (int i = 1; i <= log; i++) update(p >> i);",
            "    }",
            "",
            "    S get(int p) {",
            "        assert(0 <= p && p < _n);",
            "        p += size;",
            "        for (int i = log; i >= 1; i--) push(p >> i);",
            "        return d[p];",
            "    }",
            "",
            "    S prod(int l, int r) {",
            "        assert(0 <= l && l <= r && r <= _n);",
            "        if (l == r) return e();",
            "",
            "        l += size;",
            "        r += size;",
            "",
            "        for (int i = log; i >= 1; i--) {",
            "            if (((l >> i) << i) != l) push(l >> i);",
            "            if (((r >> i) << i) != r) push(r >> i);",
            "        }",
            "",
            "        S sml = e(), smr = e();",
            "        while (l < r) {",
            "            if (l & 1) sml = op(sml, d[l++]);",
            "            if (r & 1) smr = op(d[--r], smr);",
            "            l >>= 1;",
            "            r >>= 1;",
            "        }",
            "",
            "        return op(sml, smr);",
            "    }",
            "",
            "    S all_prod() { return d[1]; }",
            "",
            "    void apply(int p, F f) {",
            "        assert(0 <= p && p < _n);",
            "        p += size;",
            "        for (int i = log; i >= 1; i--) push(p >> i);",
            "        d[p] = mapping(f, d[p]);",
            "        for (int i = 1; i <= log; i++) update(p >> i);",
            "    }",
            "    void apply(int l, int r, F f) {",
            "        assert(0 <= l && l <= r && r <= _n);",
            "        if (l == r) return;",
            "",
            "        l += size;",
            "        r += size;",
            "",
            "        for (int i = log; i >= 1; i--) {",
            "            if (((l >> i) << i) != l) push(l >> i);",
            "            if (((r >> i) << i) != r) push((r - 1) >> i);",
            "        }",
            "",
            "        {",
            "            int l2 = l, r2 = r;",
            "            while (l < r) {",
            "                if (l & 1) all_apply(l++, f);",
            "                if (r & 1) all_apply(--r, f);",
            "                l >>= 1;",
            "                r >>= 1;",
            "            }",
            "            l = l2;",
            "            r = r2;",
            "        }",
            "",
            "        for (int i = 1; i <= log; i++) {",
            "            if (((l >> i) << i) != l) update(l >> i);",
            "            if (((r >> i) << i) != r) update((r - 1) >> i);",
            "        }",
            "    }",
            "",
            "    /// @brief ",
            "    /// @tparam g bool g(S x)",
            "    /// @param l ",
            "    /// @return g(op(a[l], ... , a[r - 1])) = true となる最大の r",
            "    template <bool (*g)(S)>",
            "    int max_right(int l) {",
            "        return max_right(l, [](S x) { return g(x); });",
            "    }",
            "    template <class G>",
            "    int max_right(int l, G g) {",
            "        assert(0 <= l && l <= _n);",
            "        assert(g(e()));",
            "        if (l == _n) return _n;",
            "        l += size;",
            "        for (int i = log; i >= 1; i--) push(l >> i);",
            "        S sm = e();",
            "        do {",
            "            while (l % 2 == 0) l >>= 1;",
            "            if (!g(op(sm, d[l]))) {",
            "                while (l < size) {",
            "                    push(l);",
            "                    l = (2 * l);",
            "                    if (g(op(sm, d[l]))) {",
            "                        sm = op(sm, d[l]);",
            "                        l++;",
            "                    }",
            "                }",
            "                return l - size;",
            "            }",
            "            sm = op(sm, d[l]);",
            "            l++;",
            "        } while ((l & -l) != l);",
            "        return _n;",
            "    }",
            "",
            "    /// @brief ",
            "    /// @tparam g bool g(S x)",
            "    /// @param r ",
            "    /// @return g(op(a[l], ... , a[r - 1])) = true となる最小の l",
            "    template <bool (*g)(S)>",
            "    int min_left(int r) {",
            "        return min_left(r, [](S x) { return g(x); });",
            "    }",
            "    template <class G>",
            "    int min_left(int r, G g) {",
            "        assert(0 <= r && r <= _n);",
            "        assert(g(e()));",
            "        if (r == 0) return 0;",
            "        r += size;",
            "        for (int i = log; i >= 1; i--) push((r - 1) >> i);",
            "        S sm = e();",
            "        do {",
            "            r--;",
            "            while (r > 1 && (r % 2)) r >>= 1;",
            "            if (!g(op(d[r], sm))) {",
            "                while (r < size) {",
            "                    push(r);",
            "                    r = (2 * r + 1);",
            "                    if (g(op(d[r], sm))) {",
            "                        sm = op(d[r], sm);",
            "                        r--;",
            "                    }",
            "                }",
            "                return r + 1 - size;",
            "            }",
            "            sm = op(d[r], sm);",
            "        } while ((r & -r) != r);",
            "        return 0;",
            "    }",
            "",
            "   private:",
            "    int _n, size, log;",
            "    std::vector<S> d;",
            "    std::vector<F> lz;",
            "",
            "    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }",
            "    void all_apply(int k, F f) {",
            "        d[k] = mapping(f, d[k]);",
            "        if (k < size) lz[k] = composition(f, lz[k]);",
            "    }",
            "    void push(int k) {",
            "        all_apply(2 * k, lz[k]);",
            "        all_apply(2 * k + 1, lz[k]);",
            "        lz[k] = id();",
            "    }",
            "};",
            "",
            "// data の型",
            "struct S {",
            "    ",
            "};",
            "",
            "// lazy の型",
            "struct F {",
            "",
            "};",
            "",
            "// 区間取得の二項演算",
            "S op(S a, S b) {",
            "",
            "}",
            "",
            "// 区間取得した結果に区間変更を入れるとどうなるか",
            "S mapping(F f, S x) {",
            "",
            "}",
            "",
            "// 区間変更の合成写像",
            "F composition(F f, F g) {",
            "",
            "}",
            "",
            "// 恒等写像 ",
            "// 区間更新の場合は取り得ない値を入れて、mapping と composition で条件分岐する",
            "F id() {",
            "",
            "}",
            "",
            "// data の単位元",
            "S e() {",
            "",
            "}",
        ],
        "description": ""
    },

    "rotate_point": {
        "prefix": "rotate_point",
        
        "body": [
            "const double PI = 3.141592653589793238462643383279;",
            "pair<double, double> rotate_point(double cx, double cy, double base_x, double base_y, double theta) {",
            "    complex<double> comp(cx - base_x, cy - base_y);",
            "    comp *= exp(complex<double>(.0, theta * PI / 180.0));",
            "    return make_pair(comp.real() + base_x, comp.imag() + base_y);",
            "}",
        ],
        "description": ""
    },

    "count_continuous_elements": {
        "prefix": "count_continuous_elements",
        
        "body": [
            "template<typename T>",
            "int count_continuous_elements(vector<T> &v, bool cyclic=false) {",
            "    int n = (int)v.size();",
            "    if (n == 1) return 1;",
            "",
            "    int res = 0, cnt = 0;",
            "",
            "    if (cyclic) {",
            "        vector<T> v2(2 * n);",
            "        for (int i = 0; i < n; i++) v2[i] = v2[i + n] = v[i];",
            "        for (int i = 0; i < 2 * n - 1; i++) {",
            "            cnt++;",
            "            if (v2[i] != v2[i + 1]) {",
            "                res = max(res, cnt);",
            "                cnt = 0;",
            "            }",
            "        }",
            "        cnt += (v2[2 * n - 2] == v2[2 * n - 1]);",
            "        res = max(res, cnt);",
            "        res = min(res, n);",
            "    } else {",
            "        for (int i = 0; i < n - 1; i++) {",
            "            cnt++;",
            "            if (v[i] != v[i + 1]) {",
            "                res = max(res, cnt);",
            "                cnt = 0;",
            "            }",
            "        }",
            "        cnt += (v[n - 2] == v[n - 1]);",
            "        res = max(res, cnt);",
            "    }",
            "",
            "    return res;",
            "}",
        ],
        "description": ""
    },

    "geom_point": {
        "prefix": "geom_point",
        
        "body": [
            "struct Point {",
            "    long long x, y;",
            "",
            "    Point(long long x_ = 0, long long y_ = 0) : x(x_), y(y_) {}",
            "",
            "    // bool operator== (const Point& other) const {",
            "    //     return x == other.x && y == other.y;",
            "    // }",
            "    // bool operator!= (const Point& other) const {",
            "    //     return x != other.x || y != other.y;",
            "    // }",
            "",
            "    // // 通常の比較演算子 (pair と同じ挙動)",
            "    // bool operator< (const Point& other) const {",
            "    //     if (x == other.x) return y < other.y;",
            "    //     else return x < other.x;",
            "    // }",
            "",
            "    // 偏角ソート用 (角度が等しければ true)",
            "    bool operator== (const Point& other) const {",
            "        return x * other.y - other.x * y == 0;",
            "    }",
            "    bool operator!= (const Point& other) const {",
            "        return x * other.y - other.x * y != 0;",
            "    }",
            "",
            "    // 偏角ソート用 (反時計回りの偏角が 180 度未満なら true)",
            "    bool operator< (const Point& other) const {",
            "        return x * other.y - other.x * y > 0;",
            "    }",
            "};",
        ],
        "description": ""
    },

    "fraction": {
        "prefix": "fraction",
        "body": [
            "struct Fraction {",
            "    long long numerator;        // 分子",
            "    long long denominator;      // 分母",
            "    bool is_inf = false;        // +- infinity か",
            "    bool is_zero = false;       // 0 か",
            "    bool is_minus = false;      // 数として負か",
            "    bool is_both_zero = false;  // 分母も分子も 0 (扱い分からん！)",
            "",
            "    Fraction(long long numerator_, long long denominator_) {",
            "        if (numerator_ == 0) is_zero = true;",
            "        if (denominator_ == 0) {",
            "            if (numerator_ == 0) is_both_zero = true;",
            "            is_inf = true;",
            "            if (numerator_ < 0) is_minus = true;",
            "        } else {",
            "            is_inf = false;",
            "            if ((numerator_ < 0 && denominator_ > 0) ||",
            "                (numerator_ > 0 && denominator_ < 0)) {",
            "                is_minus = true;",
            "                numerator_ = abs(numerator_);",
            "                denominator_ = abs(denominator_);",
            "            }",
            "            if (numerator_ != 0) {",
            "                long long g = __gcd(denominator_, numerator_);",
            "                denominator = denominator_ / g;",
            "                numerator = numerator_ / g;",
            "            } else {",
            "                denominator = denominator_;",
            "                numerator = numerator_;",
            "            }",
            "        }",
            "    }",
            "",
            "    bool operator==(const Fraction& other) const {",
            "        // 両方 +- inf のとき",
            "        if (is_minus == other.is_minus && is_inf && other.is_inf) return true;",
            "        if (is_both_zero != other.is_both_zero) return false;",
            "        // 両方 0 のとき",
            "        if (numerator == 0 && other.numerator == 0) return true;",
            "        // それ以外",
            "        return is_minus == other.is_minus && denominator == other.denominator &&",
            "               numerator == other.numerator;",
            "    }",
            "",
            "    // オーバーフロー注意",
            "    bool operator<(const Fraction& other) const {",
            "        if (is_inf && other.is_inf) return is_minus < other.is_minus;",
            "        if (is_inf) return true;",
            "        if (is_minus && is_inf) return false;",
            "",
            "        if (numerator == 0) {",
            "            return other.numerator && !other.is_minus;",
            "        }",
            "",
            "        if (is_minus) {",
            "            if (!other.is_minus) return true;",
            "            return numerator * other.denominator >",
            "                   other.numerator * denominator;",
            "        } else {",
            "            return numerator * other.denominator <",
            "                   other.numerator * denominator;",
            "        }",
            "    }",
            "",
            "    // -1 倍する",
            "    Fraction minus() {",
            "        if (is_minus) return Fraction{numerator, denominator};",
            "        return Fraction{-numerator, denominator};",
            "    }",
            "",
            "    // 逆数を取る",
            "    Fraction inv() {",
            "        if (is_minus) return Fraction{-denominator, numerator};",
            "        return Fraction{denominator, numerator};",
            "    }",
            "};",
            "",
            "ostream& operator<<(ostream& st, const Fraction f) {",
            "    if (f.is_minus) st << \"-\";",
            "    st << f.numerator << \"/\" << f.denominator;",
            "    return st;",
            "};",
        ],
        "description": ""
    },

    "tolower": {
        "prefix": "tolower_transform",
        "body": [
            "transform ($1.begin(), $1.end(), $1.begin(), ::tolower);",
        ],
        "description": ""
    },

    "toupper": {
        "prefix": "toupper_transform",
        "body": [
            "transform ($1.begin(), $1.end(), $1.begin(), ::toupper);",
        ],
        "description": ""
    },

    "usings": {
        "prefix": "usings",
        "body": [
            "using vi = vector<int>;",
            "using vvi = vector<vi>;",
            "using vvvi = vector<vvi>;",
            "using vl = vector<ll>;",
            "using vvl = vector<vl>;",
            "using vvvl = vector<vvl>;",
            "using pii = pair<int, int>;",
            "using pll = pair<ll, ll>;",
        ],
        "description": ""
    },

    "longest_increasing_subsequence": {
        "prefix": "longest_increasing_subsequence",
        "body": [
            "// https://ei1333.github.io/luzhiled/snippets/dp/longest-increasing-subsequence.html",
            "template<typename T>",
            "int longest_increasing_subseqence(const std::vector<T> &v, bool strict) {",
            "    std::vector<T> lis;",
            "    for (auto &e : v) {",
            "        typename std::vector<T>::iterator itr;",
            "        if (strict) {",
            "            itr = std::lower_bound(lis.begin(), lis.end(), e);",
            "        } else {",
            "            itr = std::upper_bound(lis.begin(), lis.end(), e);",
            "        }",
            "        if (itr == lis.end()) {",
            "            lis.push_back(e);",
            "        } else {",
            "            *itr = e;",
            "        }",
            "    }",
            "    return lis.size();",
            "}",
        ],
        "description": ""
    },

    "partitions": {
        "prefix": "partitions",
        "body": [
            "template <typename T>",
            "struct Partitions {",
            "   private:",
            "    /// @brief 自然数 n を c 分割した結果を vector に格納し、それらをまとめて",
            "    /// vector にして返す。",
            "    /// @tparam T",
            "    /// @param n",
            "    /// @param c",
            "    /// @param strict 各分割が 0 より大きくならないといけないか",
            "    /// @param zero_end_ok 最後の要素に 0 が入っても良いか",
            "    /// @return",
            "    void partition_num_impl(T n, T c, std::vector<T> &current_partition,",
            "                            std::vector<std::vector<T>> &result_partitions,",
            "                            bool &strict, bool &zero_end_ok) {",
            "        if (n == 0 && (int)current_partition.size() == c) {",
            "            if (!zero_end_ok and current_partition.back() == 0) return;",
            "            result_partitions.push_back(current_partition);",
            "            return;",
            "        }",
            "        if (n < 0 || (int)current_partition.size() > c) return;",
            "",
            "        int start = (int)strict;",
            "        if (zero_end_ok && (int)current_partition.size() == c - 1) {",
            "            start = 0;",
            "        }",
            "",
            "        for (int i = start; i <= n; i++) {",
            "            int remain = n - i;",
            "            current_partition.push_back(i);",
            "            partition_num_impl(remain, c, current_partition, result_partitions,",
            "                               strict, zero_end_ok);",
            "            current_partition.pop_back();",
            "        }",
            "    }",
            "",
            "   public:",
            "    /// @brief 自然数 n を c 分割した結果を vector に格納し、それらをまとめて",
            "    /// vector にして返す。",
            "    /// @tparam T",
            "    /// @param n",
            "    /// @param c",
            "    /// @param strict 各分割が 0 より大きくならないといけないか",
            "    /// @param zero_end_ok 最後の要素に 0 が入っても良いか",
            "    /// @return",
            "    std::vector<std::vector<T>> partition_num(T n, T c, bool strict = true,",
            "                                              bool zero_end_ok = false) {",
            "        std::vector<std::vector<T>> result_partitions;",
            "        std::vector<T> current_partition;",
            "",
            "        partition_num_impl(n, c, current_partition, result_partitions, strict,",
            "                           zero_end_ok);",
            "        return result_partitions;",
            "    }",
            "};",
        ],
        "description": ""
    },

    "dijkstra": {
        "prefix": "dijkstra",
        "body": [
            "// vector<int> edgenum(MAX_N, -1);",
            "struct Edge {",
            "    int to;",
            "    ll cost;",
            "    // int id;",
            "};",
            "",
            "void dijkstra(const vector<vector<Edge>> &G, int s, vector<ll> &dis) {",
            "    assert(dis.size() == G.size());",
            "    ",
            "    // (距離, 頂点番号) の priority queue",
            "    using pli = pair<long long, int>;",
            "    priority_queue<pli, vector<pli>, greater<pli>> pq;",
            "",
            "    // 訪れたかどうかを管理する vector",
            "    vector<bool> seen((int)G.size());",
            "",
            "    dis[s] = 0;",
            "    pq.emplace(dis[s], s);",
            " ",
            "    while (!pq.empty()) {",
            "        auto [cur_d, cur_v] = pq.top(); pq.pop();",
            " ",
            "        if (seen[cur_v]) continue;",
            "        seen[cur_v] = true;",
            " ",
            "        for (auto &[nxt_v, nxt_d] : G[cur_v]) {",
            "            if (chmin(dis[nxt_v], dis[cur_v] + nxt_d)) { // 最短距離候補",
            "                pq.push({dis[nxt_v], nxt_v});",
            "                // edgenum[e.to] = e.id;",
            "            }",
            "        }",
            "    }",
            "}",
        ],
        "description": ""
    },
}